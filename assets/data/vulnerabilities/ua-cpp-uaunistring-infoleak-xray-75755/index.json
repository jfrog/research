{"hash":"97565493b67c00b4f520e2cfb22ade19948f382e","data":{"post":{"title":"Unified Automation C++ based OPC UA Client Server SDK out of bounds read","path":"/vulnerabilities/ua-cpp-uaunistring-infoleak-xray-75755/","content":"<h2 id=\"summary\"><a href=\"#summary\" aria-hidden=\"true\" tabindex=\"-1\">Summary</a></h2>\n<p>The UaUniString::UaUniString() function in Unified Automation C++ based OPC UA Client Server SDK is vulnerable to out of bounds read issue which can allow a remote authenticated attacker to perform information leak of technical data</p>\n<h2 id=\"component\"><a href=\"#component\" aria-hidden=\"true\" tabindex=\"-1\">Component</a></h2>\n<p><a href=\"https://www.unified-automation.com/products/server-sdk/c-ua-server-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation C++ based OPC UA Client Server SDK</a>\n​</p>\n<h2 id=\"affected-versions\"><a href=\"#affected-versions\" aria-hidden=\"true\" tabindex=\"-1\">Affected versions</a></h2>\n<p>Unified Automation C++ based OPC UA Client Server SDK (, 1.7.6], fixed in 1.7.7\n​</p>\n<h2 id=\"description\"><a href=\"#description\" aria-hidden=\"true\" tabindex=\"-1\">Description</a></h2>\n<p><a href=\"https://www.unified-automation.com/products/server-sdk/c-ua-server-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation C++ based OPC UA Client Server SDK</a> is a SDK used to develop an OPC UA server in C++, Developed by the Unified Automation.</p>\n<p>The <code>UaUniString::UaUniString</code> function is vulnerable to an out of bounds read vulnerability:</p>\n<pre><code class=\"language-c\">void __thiscall UaUniString::UaUniString(UaUniString *this, const char *other)\n{\n…\n\n  thisa = this;\n  if ( other )\n  {\n    iWLen = 0;\n    for ( i = 0; other[i]; ++i )\n    {\n      c = other[i];\n      if ( c >= 128 )\n      {\n        if ( (c &#x26; 0xE0) == '\\xC0' )\n        {\n          ++i;\n          ++iWLen;\n        }\n        else if ( (c &#x26; 0xF0) == '\\xE0' )\n        {\n          i += 2;\n          ++iWLen;\n        }\n        else if ( (c &#x26; 0xF8) == '\\xF0' )\n        {\n          i += 3;\n          ++iWLen;\n        }\n        else if ( (c &#x26; 0xFC) == '\\xF8' )\n        {\n          i += 4;\n          ++iWLen;\n        }\n        else if ( (c &#x26; 0xFE) == '\\xFC' )\n        {\n          i += 5;\n          ++iWLen;\n        }\n      }\n      else\n      {\n        ++iWLen;\n      }\n    }\n    iLen = i;\n    pData = OpcUa_Memory_Alloc(2 * iWLen + 2);\n    iLenUsed = 0;\n    for ( ia = 0; ia &#x3C;= iLen; ++ia )\n    {\n      v5 = other[ia];\n      if ( v5 >= 0x80 )\n      {\n    …\n       else if ( (v5 &#x26; 0xF8) == '\\xF0' )\n        {\n          pData[iLenUsed++] = '?';\n          ia += 3;\n        }\n        else if ( (v5 &#x26; 0xFC) == '\\xF8' )\n        {\n          pData[iLenUsed++] = '?';\n          ia += 4;\n        }\n        else if ( (v5 &#x26; 0xFE) == '\\xFC' )\n        {\n          pData[iLenUsed++] = '?';\n          ia += 5;\n        }\n      }\n      else\n      {\n        pData[iLenUsed++] = other[ia];\n      }\n    }\n</code></pre>\n<p>The function calculates in the first loop the length of the converted string which is <code>iWLen</code>, when it gets to a special character(for example 0xE0) it increments the index of <code>other</code> in more than 1 without checking if it would skip over the <code>other</code>’s null terminator thus calculating a length bigger than the original string’s length.\nThe function allocates the new utf16 array for the converted string based on <code>iWLen</code>\nLater, the second loop copies the string with the length that was calculated before, this would copy any character under 0x80 into the new buffer except some special characters that would be returned as ‘?’.\nBecause the new string buffer will be written up to <code>iLen</code> which is the out of bound length the new string will contain data that is after the original string, in the heap.\nBy using the <code>index_range</code> parameter in a \"Read\" request in the OPC UA protocol, the server calls this function and returns the data to the client.</p>\n<h2 id=\"poc\"><a href=\"#poc\" aria-hidden=\"true\" tabindex=\"-1\">PoC</a></h2>\n<p>No PoC is supplied for this issue\n​</p>\n<h2 id=\"vulnerability-mitigations\"><a href=\"#vulnerability-mitigations\" aria-hidden=\"true\" tabindex=\"-1\">Vulnerability Mitigations</a></h2>\n<p>No mitigations are supplied for this issue</p>\n<h2 id=\"references\"><a href=\"#references\" aria-hidden=\"true\" tabindex=\"-1\">References</a></h2>\n","description":"Medium severity. The UaUniString::UaUniString() function in Unified Automation C++ based OPC UA Client Server SDK is vulnerable to out of bounds read issue which can allow a remote authenticated attacker to perform information leak of technical data","date_published":"2022-06-01","xray_id":"XRAY-75755","vul_id":"","severity":"medium","discovered_by":"Omer Kaspi","last_updated":"2022-06-01","cvss":null}},"context":{}}