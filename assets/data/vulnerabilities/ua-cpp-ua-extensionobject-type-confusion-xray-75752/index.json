{"hash":"b20d6eff1f7c255990634ab946f0bb5b487789ea","data":{"post":{"title":"Unified Automation PubSub stack ua_decode_extensionobject type confusion","path":"/vulnerabilities/ua-cpp-ua-extensionobject-type-confusion-xray-75752/","content":"<h2 id=\"summary\"><a href=\"#summary\" aria-hidden=\"true\" tabindex=\"-1\">Summary</a></h2>\n<p>The ua_decode_extensionobject() function in Unified Automation C based PubSub Stack is vulnerable to type confusion which can allow a remote authenticated attacker to achieve denial of service and arbitrary read</p>\n<h2 id=\"component\"><a href=\"#component\" aria-hidden=\"true\" tabindex=\"-1\">Component</a></h2>\n<p><a href=\"https://www.unified-automation.com/products/server-sdk/c-ua-server-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation C++ Based OPC UA PubSub SDK</a>\n<a href=\"https://www.unified-automation.com/products/server-sdk/ansi-c-ua-server-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation ANSI C Based OPC UA Client &#x26; Server SDK</a>\n<a href=\"https://www.unified-automation.com/products/pubsub-sdk/highperf-ua-pubsub-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation HighPerf SDK</a>\n​</p>\n<h2 id=\"affected-versions\"><a href=\"#affected-versions\" aria-hidden=\"true\" tabindex=\"-1\">Affected versions</a></h2>\n<p>Unified Automation C++ based OPC UA Client Server SDK (, 1.7.6], fixed in 1.7.7\nUnified Automation AnsiC SDK (, 1.9.2], fixed in 1.9.3\nUnified Automation HighPerf SDK (, 1.5.2], fixed in 1.6.0</p>\n<h2 id=\"description\"><a href=\"#description\" aria-hidden=\"true\" tabindex=\"-1\">Description</a></h2>\n<p>Unified Automation is a Bundle used to develop an OPC UA PubSub support in C++ and C, Developed by the Unified Automation.</p>\n<p>The <code>ua_decocde_extensionobject</code> function may be vulnerable to a type confusion vulnerability:</p>\n<pre><code class=\"language-c\">int __cdecl ua_decode_extensionobject(int *a1, void *a2)\n{\n  const char *v3; // eax\n  char v4[12]; // [esp+Ch] [ebp-20h]\n  char **v5; // [esp+18h] [ebp-14h]\n  Int type_id; // [esp+23h] [ebp-9h]\n  int v7; // [esp+28h] [ebp-4h]\n\n  v5 = 0;\n  j__ua_nodeid_init(a2);\n  v7 = j__ua_decode_nodeid(a1, a2 + 12);\n  if ( v7 )\n    return v7;\n  v7 = j__ua_decode_uint8(a1, type_id);\n  if ( !v7 )\n  {\n    *(a2 + 6) = 0;\n    *(a2 + 14) = 0;\n    if ( !j__ua_nodeid_is_null(a2 + 12) )\n    {\n      v5 = j__ua_type_table_lookup_binary_encoding(a2 + 12, a2 + 6);\n      if ( v5 )\n      {\n        j__ua_nodeid_set_numeric(a2, *(a2 + 10), v5[3]);\n        *(a2 + 14) = *(a2 + 10);\n      }\n      else\n      {\n        j__trace_log(64, 16, aUaDecodeExtens, *(a2 + 10));\n…\n           }\n    }\n    switch ( type_id )\n    {\n      case 0:\n        *(a2 + 10) = 0;\n        return 0;\n      case 1:\n        if ( v5 )\n        {\n          v7 = ua_decode_encodeableobject(a1, v5, a2);\n          if ( !v7 )\n            return 0;\n        }\n        else\n        {\n          v7 = j__ua_decode_bytestring(a1, a2 + 32);\n          if ( !v7 )\n          {\n            *(a2 + 10) = 2;\n            return 0;\n          }\n        }\n        break;\n…\n    }\n  }\n\n…\n    }\n  }\n…\n  return v7;\n}\n</code></pre>\n<p>The function uses <code>a2 + 12</code> to store the node id on the parsed extension object, it then tries to search it in namespace using <code>j__ua_type_table_lookup_binary_encoding</code> if it fails to find it and the object’s <code>type_id</code> is 1 which is binary encoding, it parses the object as bytestring.\nFurther down the execution path of the pubsub SDK, the SDK’s functions treat this object as valid which can cause unexpected behavior, we managed to crash the server using a malicous pubsub configuration by making the pubsub SDK to treat the length field of the bytestring as a pointer in <code>w_cfg = (ua_uadpdatasetwritermessagedatatype *)w->config_object->message_settings.body.obj</code> in function <code>writergroup_datasetmsg_init_order</code>\nGiven a big enough string this can cause arbitrary read from any location in memory by treating the length field as pointer</p>\n<h2 id=\"poc\"><a href=\"#poc\" aria-hidden=\"true\" tabindex=\"-1\">PoC</a></h2>\n<p>No PoC is supplied for this issue\n​</p>\n<h2 id=\"vulnerability-mitigations\"><a href=\"#vulnerability-mitigations\" aria-hidden=\"true\" tabindex=\"-1\">Vulnerability Mitigations</a></h2>\n<p>No mitigations are supplied for this issue</p>\n<h2 id=\"references\"><a href=\"#references\" aria-hidden=\"true\" tabindex=\"-1\">References</a></h2>\n","description":"CVE-2022-xxxx Medium severity. The ua_decode_extensionobject() function in Unified Automation C based PubSub Stack is vulnerable to type confusion issue which can allow a remote authenticated attacker to achieve denial of service and arbitrary read","date_published":"2022-06-01","xray_id":"XRAY-75752","vul_id":"","severity":"medium","discovered_by":"Omer Kaspi","last_updated":"2022-06-01","cvss":null}},"context":{}}