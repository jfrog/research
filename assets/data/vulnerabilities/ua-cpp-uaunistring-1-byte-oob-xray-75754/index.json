{"hash":"8fe2ef72bdba621246c325748e78edd3cae7bff8","data":{"post":{"title":"Unified Automation C++ based OPC UA Client Server SDK 1-byte out of bounds read","path":"/vulnerabilities/ua-cpp-uaunistring-1-byte-oob-xray-75754/","content":"<h2 id=\"summary\"><a href=\"#summary\" aria-hidden=\"true\" tabindex=\"-1\">Summary</a></h2>\n<p>The UaString::toUtf16() function in Unified Automation C++ based OPC UA Client Server SDK is vulnerable to 1-byte out of bound read issue which can allow a remote unauthenticated attacker to perform Denial of Service</p>\n<h2 id=\"component\"><a href=\"#component\" aria-hidden=\"true\" tabindex=\"-1\">Component</a></h2>\n<p><a href=\"https://www.unified-automation.com/products/server-sdk/c-ua-server-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation C++ based OPC UA Client Server SDK</a>\n​</p>\n<h2 id=\"affected-versions\"><a href=\"#affected-versions\" aria-hidden=\"true\" tabindex=\"-1\">Affected versions</a></h2>\n<p>Unified Automation C++ based OPC UA Client Server SDK (, 1.7.6], fixed in 1.7.7\n​</p>\n<h2 id=\"description\"><a href=\"#description\" aria-hidden=\"true\" tabindex=\"-1\">Description</a></h2>\n<p><a href=\"https://www.unified-automation.com/products/server-sdk/c-ua-server-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation C++ based OPC UA Client Server SDK</a> is a SDK used to develop an OPC UA server in C++, Developed by the Unified Automation.</p>\n<p>The <code>UaString::toUtf16</code> function may be vulnerable to 1-byte out of bound read vulnerability:</p>\n<pre><code class=\"language-c\">UaByteArray *__thiscall UaString::toUtf16(UaString *this, UaByteArray *result)\n{\n  UaByteArray *v2; // eax\n  unsigned int *v3; // [esp+Ch] [ebp-70h]\n  unsigned int *v4; // [esp+10h] [ebp-6Ch]\n  unsigned int *v5; // [esp+14h] [ebp-68h]\n  unsigned int *v6; // [esp+18h] [ebp-64h]\n  unsigned int *v7; // [esp+1Ch] [ebp-60h]\n  UaByteArray resulta; // [esp+28h] [ebp-54h]\n  unsigned __int16 cValTmp; // [esp+30h] [ebp-4Ch]\n  unsigned int cVal; // [esp+34h] [ebp-48h]\n  int iLenUsed; // [esp+38h] [ebp-44h]\n  unsigned __int16 *pUTF16Data; // [esp+3Ch] [ebp-40h]\n  char c; // [esp+43h] [ebp-39h]\n  int i; // [esp+44h] [ebp-38h]\n  UaUInt32Array unicodeCharacters; // [esp+4Ch] [ebp-30h]\n  int uniCodeLen; // [esp+5Ch] [ebp-20h]\n  int iLen; // [esp+60h] [ebp-1Ch]\n  char *pOther; // [esp+64h] [ebp-18h]\n  const UaStringPrivate *d; // [esp+68h] [ebp-14h]\n  const UaString *thisa; // [esp+6Ch] [ebp-10h]\n  int v21; // [esp+78h] [ebp-4h]\n\n  thisa = this;\n  d = UaString::d_func(this);\n  pOther = OpcUa_String_GetRawString(d);\n  iLen = UaStringPrivate::size(d);\n  if ( pOther )\n  {\n    uniCodeLen = 0;\n    UaUInt32Array::UaUInt32Array(&#x26;unicodeCharacters);\n    v21 = 0;\n    UaUInt32Array::resize(&#x26;unicodeCharacters, iLen);\n    for ( i = 0; i &#x3C; iLen; ++i )\n    {\n      c = pOther[i];\n      if ( c >= 128 )\n      {\n        if ( (c &#x26; 0xE0) == 192 )\n        {\n          *UaUInt32Array::operator[](&#x26;unicodeCharacters, uniCodeLen) = (c &#x26; 0x1F) &#x3C;&#x3C; 6;\n          c = pOther[++i];\n          v7 = UaUInt32Array::operator[](&#x26;unicodeCharacters, uniCodeLen);\n          *v7 |= c &#x26; 0x3F;\n          ++uniCodeLen;\n        }\n        else if ( (c &#x26; 0xF0) == 0xE0 )\n        {\n          *UaUInt32Array::operator[](&#x26;unicodeCharacters, uniCodeLen) = (c &#x26; 0xF) &#x3C;&#x3C; 12;\n          c = pOther[++i];\n          v6 = UaUInt32Array::operator[](&#x26;unicodeCharacters, uniCodeLen);\n          *v6 |= (c &#x26; 0x3F) &#x3C;&#x3C; 6;\n          c = pOther[++i];\n          v5 = UaUInt32Array::operator[](&#x26;unicodeCharacters, uniCodeLen);\n          *v5 |= c &#x26; 0x3F;\n          ++uniCodeLen;\n        }\n…\n</code></pre>\n<p>The function uses <code>i</code> to access the string stored in <code>this</code> when the character read is 0xE0 it read 2 other characters without checking that <code>i</code> doesn’t pass the <code>iLen</code> size, this can cause one byte out of bound read after the NULL terminator of the string.\nThis can cause denial of service if the string is located near a non accessible page.</p>\n<h2 id=\"poc\"><a href=\"#poc\" aria-hidden=\"true\" tabindex=\"-1\">PoC</a></h2>\n<p>No PoC is supplied for this issue\n​</p>\n<h2 id=\"vulnerability-mitigations\"><a href=\"#vulnerability-mitigations\" aria-hidden=\"true\" tabindex=\"-1\">Vulnerability Mitigations</a></h2>\n<p>No mitigations are supplied for this issue</p>\n<h2 id=\"references\"><a href=\"#references\" aria-hidden=\"true\" tabindex=\"-1\">References</a></h2>\n","description":"Medium severity. The UaString::toUtf16() function in Unified Automation C++ based OPC UA Client Server SDK is vulnerable to 1-byte out of bound read issue which can allow a remote unauthenticated attacker to perform Denial of Service","date_published":"2022-06-01","xray_id":"XRAY-75754","vul_id":"","severity":"medium","discovered_by":"Omer Kaspi","last_updated":"2022-06-01","cvss":null}},"context":{}}