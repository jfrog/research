{"hash":"468e72ee99cf776ad0fbbbaabc5c11fd0eaa9370","data":{"post":{"title":"Unified Automation PubSub stack authenticated out-of-bounds write","path":"/vulnerabilities/ua-cpp-replaceargs-oob-write-xray-75751/","content":"<h2 id=\"summary\"><a href=\"#summary\" aria-hidden=\"true\" tabindex=\"-1\">Summary</a></h2>\n<p>The <code>replaceArgEscapes()</code> function in Unified Automation C-based PubSub Stack is vulnerable to an out of bounds write issue. An authenticated remote attacker can cause denial of service or in some cases achieve remote code execution</p>\n<h2 id=\"component\"><a href=\"#component\" aria-hidden=\"true\" tabindex=\"-1\">Component</a></h2>\n<p><a href=\"https://www.unified-automation.com/products/server-sdk/c-ua-server-sdk.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Unified Automation C++ Based OPC UA PubSub SDK</a>\n​</p>\n<h2 id=\"affected-versions\"><a href=\"#affected-versions\" aria-hidden=\"true\" tabindex=\"-1\">Affected versions</a></h2>\n<p>Unified Automation C++ based OPC UA Client Server SDK (, 1.7.6], fixed in 1.7.7\nUnified Automation AnsiC SDK (, 1.9.2], fixed in 1.9.3\nUnified Automation HighPerf SDK (, 1.5.2], fixed in 1.6.0</p>\n<h2 id=\"description\"><a href=\"#description\" aria-hidden=\"true\" tabindex=\"-1\">Description</a></h2>\n<p>Unified Automation is a Bundle used to develop an OPC UA PubSub support in C++ and C, Developed by the Unified Automation.</p>\n<p><code>String::arg()</code> takes a string input and replaces every <code>%1</code> , <code>%2</code> (and so on) with an argument.\nThere are some uses in this function that looks like this:\n<code>“%1.%2”.arg(s1).arg(s2)</code>\nIf <code>s1</code> itself contains <code>%1</code> then the next <code>arg()</code> call will paste <code>s2</code> where originally <code>s1</code> should have been placed.</p>\n<p><code>UaString::arg()</code> calls <code>findArgEscapes(ArgEscapeData *d, const UaString *s)</code> which sets <code>d->occurences</code> to the number of the lowest argument id in the format string (i.e for <code>“%1%1%2”</code> the function will count only the <code>“%1”</code> in the string) and sets <code>d->escape_len</code> to the accumulated length of all of the arguments in the string (in the previous example it will be 4).\nLater, <code>UaString::arg()</code> will call <code>replaceArgEscapes()</code> in order to replace the lowest argument id with the given argument string.\n<code>replaceArgEscapes()</code> will allocate a buffer that should be big enough to contain the string after the replacements:</p>\n<pre><code class=\"language-c\">UaString *replaceArgEscapes(UaString *result, const UaString *fmt_string, const ArgEscapeData *d, int field_width, const UaString *arg, const UaChar *fillChar)\n{\n    //..\nv__field_width_abs = uaAbs&#x3C;int>(&#x26;field_width);\nv__fmt_string_size = UaString::size((UaString *)fmt_string);\nv__arg_size = UaString::size((UaString *)arg);\nv__size_without_escape_len = v__fmt_string_size - d->escape_len;\nlen = *uaMax&#x3C;int>(&#x26;v__field_width_abs, &#x26;v__arg_size) * d->occurrences +\nv__size_without_escape_len;\nbuf = (char *)OpcUa_Memory_Alloc(len + 1);\n</code></pre>\n<p>There is an integer overflow in this code. It calculates the required allocation size in this way:\n<code>max(abs(field_width), arg_size) * d->occurences + (fmt_string_size - d->escape_len)</code>\nWhere the result will be assigned to an unsigned integer.\nThis calculation might lead to an integer overflow when this parameters are big numbers, for example if the format string is 0x10000 times <code>“%1”</code>, <code>arg_size</code> is 0x10001 bytes long and <code>field_width</code> is 1 bytes then <code>d->occurrences</code> will be 0x10000, the <code>fmt_string_size</code> will be 0x20000 and <code>d->escape_len</code> will be also 0x20000. These numbers brings the result of 0x10001*0x10000 + 0 = 0x10000. This will result in a buffer with a size that is smaller than expected.</p>\n<p>Later, <code>replaceArgEscapes()</code> will copy the format string to the allocated buffer, where for each argument slot (“%1”) it will write the argument string. This will lead to write of the allocated buffer bounds and in certain cases also to remote code execution.</p>\n<h2 id=\"poc\"><a href=\"#poc\" aria-hidden=\"true\" tabindex=\"-1\">PoC</a></h2>\n<p>No PoC is supplied for this issue\n​</p>\n<h2 id=\"vulnerability-mitigations\"><a href=\"#vulnerability-mitigations\" aria-hidden=\"true\" tabindex=\"-1\">Vulnerability Mitigations</a></h2>\n<p>No mitigations are supplied for this issue</p>\n<h2 id=\"references\"><a href=\"#references\" aria-hidden=\"true\" tabindex=\"-1\">References</a></h2>\n","description":"High severity. The replaceArgEscapes() function in Unified Automation C-based PubSub Stack is vulnerable to an out of bounds write issue. An authenticated remote attacker can cause denial of service or in some cases achieve remote code execution","date_published":"2022-06-01","xray_id":"XRAY-75751","vul_id":"","severity":"high","discovered_by":"Omer Kaspi","last_updated":"2022-06-01","cvss":null}},"context":{}}